/*
 * File name: Ex3.java
 * File purpose: navigate through multiple loops maze
 * Author: Elena Pemkute
 * Created: December 2017
 */

import uk.ac.warwick.dcs.maze.logic.IRobot;
import java.util.ArrayList;


public class Ex3 {

  private int pollRun = 0;
  private RobotData3 robotData;
  private int explorerMode;

   /*
   * A method to count the number of non-wall squares in relation to the robot position
   *
   * @param robot   the robot object
   * @return returns the number of non-WALL squares counted by the method
   */
  private int nonwallExits (IRobot robot) {
     int walls = 0;
     for (int i = IRobot.AHEAD; i <= IRobot.LEFT; i++) {
       if(robot.look(i) == IRobot.WALL)
       walls++;
     }

     int nowalls = 4 - walls;
     return nowalls;
   }

   /*
   * A method to count the number of passage squares in relation to the robot position
   *
   * @param robot   the robot object
   * @return returns the number of passage squares counted by the method
   */
  private int passageExits (IRobot robot) {
     int pass = 0;
     for (int i = IRobot.AHEAD; i <= IRobot.LEFT; i++) {
       if(robot.look(i) == IRobot.PASSAGE)
       pass++;
     }
     return pass;
   }

   /*
   * Counts the number of beenbefore squares in relation to the robot position
   *
   * @param robot   the robot object
   * @return returns the number of beenbefore squares counted by the method
   */
  private int beenbeforeExits (IRobot robot) {
     int been = 0;
     for (int i = IRobot.AHEAD; i <= IRobot.LEFT; i++) {
       if(robot.look(i) == IRobot.BEENBEFORE)
       been++;
     }
     return been;
   }

   /*
   * A method that provides a heading to move when entered a DeadEnd
   *
   * @param robot   the robot object
   * @return returns the heading generated by the method
   */
  private int DeadEnd(IRobot robot) {
     int dir = IRobot.AHEAD;

     while (robot.look(dir) == IRobot.WALL) {
       dir++;
     }
     return dir;
   }

   /*
   * A method that provides an unexplored heading to move when entered a Corridor
   *
   * @param robot   the robot object
   * @return returns the heading generated by the method
   */
  private int Corridor(IRobot robot) {
     if (robot.look(IRobot.AHEAD) != IRobot.WALL ) {
        return IRobot.AHEAD;
     }
     else if (robot.look(IRobot.LEFT) != IRobot.WALL ) {
        return IRobot.LEFT;
     }
     else return IRobot.RIGHT;
   }

   /*
   * A method that provides an unexplored heading, if there is one,
   * otherwise a random beenbefore heading
   * to move when entered a Junction or Crossroad
   *
   * Junction and Crossroad method is combined into one,
   * because they both serve the same purpose.
   *
   * @param robot   the robot object
   * @return returns the heading generated by the method
   */
  private int JuncOrCross(IRobot robot) {
     int dir = IRobot.AHEAD;
     int p = passageExits(robot);
     int randno;
     if(p>0)
        do {
         randno = (int) Math.round(Math.random()*3);
         switch(randno) {
           case 0:
       	      dir = IRobot.LEFT;
              break;
       	   case 1:
       	      dir = IRobot.RIGHT;
              break;
       	   case 2:
       	      dir = IRobot.BEHIND;
              break;
       	   default:
       	      dir = IRobot.AHEAD;
           }
        } while (robot.look(dir) != IRobot.PASSAGE);

     else do {
          randno = (int) Math.round(Math.random()*3);
          switch(randno) {
            case 0:
        	      dir = IRobot.LEFT;
                break;
        	  case 1:
        	      dir = IRobot.RIGHT;
                break;
        	  case 2:
        	      dir = IRobot.BEHIND;
                break;
        	  default:
        	      dir = IRobot.AHEAD;
          }
        } while (robot.look(dir) != IRobot.BEENBEFORE);
     return dir;
   }

   /*
   * An exploring controller that passes to four sensibly named subsidiary methods
   * depending on the value of exits variable
   *
   * If a new junction is encountered, then it is recorded
   *
   * If an explored once junction is encountered, then it turn around
   *
   * @param robot   the robot object
   * @return returns the heading generated by the method
   */
  public int exploreControl (IRobot robot) {
    int exits = nonwallExits(robot);
    int direction = IRobot.AHEAD;

    switch(exits) {
      case 1:
        if (pollRun == 0)
        direction = DeadEnd(robot);
        else direction = backtrackControl(robot);
        break;
      case 2:
        direction = Corridor(robot);
        break;
      case 3:
      default:
        if (beenbeforeExits(robot) == 1) {
          robotData.recordJunction(robot);
          direction = JuncOrCross(robot);
        }
        else {
          direction = IRobot.BEHIND;
          explorerMode = 0;
        }
      }
    return direction;
  }

  /*
  * A backtracking controller that passes to four sensibly named subsidiary methods
  * depending on the value of exits variable
  *
  * If a fully explored junction is encountered,
  * then it backtracks to the direction where it first came from
  *
  * @param robot   the robot object
  * @return returns the heading generated by the method
  */
  public int backtrackControl(IRobot robot) {
    int exits = nonwallExits(robot);
    int direction = IRobot.AHEAD;

    switch(exits) {
      case 1:
        direction = DeadEnd(robot);
        break;
      case 2:
        direction = Corridor(robot);
        break;
      case 3:
      default:
        if (passageExits(robot) == 0 ) {
          int firstenter = robotData.searchJunction(robot.getLocation().x, robot.getLocation().y);
          int opposite;

          if(firstenter - 1000 < 2 )
            opposite = firstenter + 2;
          else
            opposite = firstenter - 2;

          robot.setHeading(opposite);
          direction  = IRobot.AHEAD;
        }
       else  {
         direction = JuncOrCross(robot);
         explorerMode = 1;
       }

    }
    return direction;
  }

  /*
  * The main controller that passes to exploring or backtracking control
  * depending on situation
  *
  * @param robot   the robot object
  */
  public void controlRobot(IRobot robot){
      int go;
      // On the first move of the first run of a new maze
      if ((robot.getRuns() == 0) && (pollRun == 0)) {
         robotData = new RobotData3(); //reset the data store
         explorerMode = 1;
       }

      if (explorerMode == 1)
        go = exploreControl(robot);
      else go = backtrackControl(robot);

      robot.face(go);

      pollRun++; // Increment pollRun so that the data is not
                 // reset each time the robot moves
   }

   /*
   * A method to reset recorded data
   */
  public void reset() {
     robotData.resetJunctionCounter();
     robotData.resetArrayList();
     explorerMode = 1;
   }
 }

class RobotData3 {
      private static int junctionCounter;
      ArrayList junctionRecorder = new ArrayList();

      /*
      * A method to record robots currect location and its heading
      * when encountered a new junction or crossroad
      * and counting which junction or crossroad it is
      *
      * @param robot   the robot object
      */
      public void recordJunction (IRobot robot) {
        junctionRecorder.add(robot.getLocation().x);
        junctionRecorder.add(robot.getLocation().y);
        junctionRecorder.add(robot.getHeading());
        junctionCounter++;
      }

      /*
      * A method which, when given x and y coordinates of the robot,
      * returns the robot's hreading when it first entered the junction or crossroad
      *
      * @param x x coordinates of the robot
      * @param y y coordinates of the robot
      * @return returns the heading generated by the method
      */
      public int searchJunction(int x, int y) {
        int enter = 0;
        for (int i = 1; i<= junctionCounter ; i++) {
          int xx = (int) junctionRecorder.get(3*(i-1));
          int yy = (int) junctionRecorder.get(3*(i-1)+1);
          int aa = (int) junctionRecorder.get(3*(i-1)+2);
          if(x == xx && y == yy)
            enter = aa;
        }
        return enter;
      }

      /*
      * A method that resets the number of junctions or crossroads
      */
      public void resetJunctionCounter() {
          junctionCounter = 0;
      }

      /*
      * A method that resets record of junction or crossroad
      */
      public void resetArrayList() {
          junctionRecorder.clear();
      }
    }

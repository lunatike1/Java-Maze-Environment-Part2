/*
 * File name: Ex2.java
 * File purpose: navigate through a maze with minimized recorded data about junctions
 * Author: Elena Pemkute
 * Created: December 2017
 */

import uk.ac.warwick.dcs.maze.logic.IRobot;
import java.util.ArrayList;

public class Ex2 {

  private int pollRun = 0;
  private RobotData2 robotData;
  private int explorerMode;
  private static int junctionCounter = 0;
  ArrayList junctionRecorder = new ArrayList();

     /*
     * A method to count the number of non-wall squares in relation to the robot position
     *
     * @param robot   the robot object
     * @return returns the number of non-WALL squares counted by the method
     */
    private int nonwallExits (IRobot robot) {
         int walls = 0;
         for (int i = IRobot.AHEAD; i <= IRobot.LEFT; i++) {
           if(robot.look(i) == IRobot.WALL)
           walls++;
         }
         int nowalls = 4 - walls;
         return nowalls;
       }

     /*
     * A method to count the number of passage squares in relation to the robot position
     *
     * @param robot   the robot object
     * @return returns the number of passage squares counted by the method
     */
    private int passageExits (IRobot robot) {
         int pass = 0;
         for (int i = IRobot.AHEAD; i <= IRobot.LEFT; i++) {
           if(robot.look(i) == IRobot.PASSAGE)
           pass++;
         }
         return pass;
       }

     /*
     * Counts the number of beenbefore squares in relation to the robot position
     *
     * @param robot   the robot object
     * @return returns the number of beenbefore squares counted by the method
     */
    private int beenbeforeExits (IRobot robot) {
         int been = 0;
         for (int i = IRobot.AHEAD; i <= IRobot.LEFT; i++) {
           if(robot.look(i) == IRobot.BEENBEFORE)
           been++;
         }
         return been;
       }

     /*
     * A method that provides a heading to move when entered a DeadEnd
     *
     * @param robot   the robot object
     * @return returns the heading generated by the method
     */
    private int DeadEnd(IRobot robot) {
         int dir = IRobot.AHEAD;

         while (robot.look(dir) == IRobot.WALL) {
           dir++;
         }
         return dir;
       }

     /*
     * A method that provides an unexplored heading to move when entered a Corridor
     *
     * @param robot   the robot object
     * @return returns the heading generated by the method
     */
    private int Corridor(IRobot robot) {
         if (robot.look(IRobot.AHEAD) != IRobot.WALL ) {
            return IRobot.AHEAD;
         }
         else if (robot.look(IRobot.LEFT) != IRobot.WALL ) {
            return IRobot.LEFT;
         }
         else return IRobot.RIGHT;
       }

     /*
     * A method that provides an unexplored heading, if there is one,
     * otherwise a random beenbefore heading
     * to move when entered a Junction or Crossroad
     *
     * Junction and Crossroad method is combined into one,
     * because they both serve the same purpose.
     *
     * @param robot   the robot object
     * @return returns the heading generated by the method
     */
    private int JuncOrCross(IRobot robot) {
         int dir = IRobot.AHEAD;
         int p = passageExits(robot);
         int randno;
         if(p>0)
            do {
             randno = (int) Math.round(Math.random()*3);
             switch(randno) {
               case 0:
           	      dir = IRobot.LEFT;
                  break;
           	   case 1:
           	      dir = IRobot.RIGHT;
                  break;
           	   case 2:
           	      dir = IRobot.BEHIND;
                  break;
           	   default:
           	      dir = IRobot.AHEAD;
               }
            } while (robot.look(dir) != IRobot.PASSAGE);

         else do {
              randno = (int) Math.round(Math.random()*3);
              switch(randno) {
                case 0:
            	      dir = IRobot.LEFT;
                    break;
            	  case 1:
            	      dir = IRobot.RIGHT;
                    break;
            	  case 2:
            	      dir = IRobot.BEHIND;
                    break;
            	  default:
            	      dir = IRobot.AHEAD;
              }
            } while (robot.look(dir) != IRobot.BEENBEFORE);
         return dir;
       }

    public void recordJunction (IRobot robot) {
        junctionRecorder.add(robot.getHeading());
    }

    public void removingjunction (IRobot robot) {
        junctionRecorder.remove(junctionCounter-1);
        junctionCounter --;
    }

    /*
    * An exploring controller that passes to four sensibly named subsidiary methods
    * depending on the value of exits variable
    * If a new junction is encountered, then it is recorded
    *
    * @param robot   the robot object
    * @return returns the heading generated by the method
    */
    public int exploreControl (IRobot robot) {
        int exits = nonwallExits(robot);
        int direction = IRobot.AHEAD;

        switch(exits) {
          case 1:
            if (pollRun == 0)
            direction = DeadEnd(robot);
            else direction = backtrackControl(robot);
            break;
          case 2:
            direction = Corridor(robot);
            break;
          case 3:
          default:
            if (beenbeforeExits(robot) == 1) {
              recordJunction(robot);
              junctionCounter ++;
              direction = JuncOrCross(robot);
            }
            else if (passageExits(robot) == 0) {
                    direction = backtrackControl(robot);
                }
            else direction = JuncOrCross(robot);
          }
        return direction;
      }

    /*
    * A backtracking controller that passes to four sensibly named subsidiary methods
    * depending on the value of exits variable
    *
    * If a fully explored junction is encountered,
    * then it backtracks to the direction where it first came from
    * and gets rid of data about this junctions
    *
    * @param robot   the robot object
    * @return returns the heading generated by the method
    */
    public int backtrackControl(IRobot robot) {
        int exits = nonwallExits(robot);
        int direction = IRobot.AHEAD;

        switch(exits) {
          case 1:
            direction = DeadEnd(robot);
            break;
          case 2:
            direction = Corridor(robot);
            break;
          case 3:
          default:
            if (passageExits(robot) == 0 ) {
              int firstenter = (int) junctionRecorder.get(junctionRecorder.size()-1);
              int opposite;

              if(firstenter - 1000 < 2 )
                opposite = firstenter + 2;
              else
                opposite = firstenter - 2;

              robot.setHeading(opposite);
              direction  = IRobot.AHEAD;
              removingjunction(robot);
            }
           else  { direction = exploreControl(robot);
           explorerMode = 0; }

        }
        return direction;
      }

      /*
      * The main controller that passes to exploring or backtracking control
      * depending on situation
      *
      * @param robot   the robot object
      */
    public void controlRobot(IRobot robot){
          int go;
          // On the first move of the first run of a new maze
          if ((robot.getRuns() == 0) && (pollRun == 0)) {
             robotData = new RobotData2(); //reset the data store
             explorerMode = 1;
           }

          if (explorerMode == 1)
            go = exploreControl(robot);
          else go = backtrackControl(robot);

          robot.face(go);

          pollRun++; // Increment pollRun so that the data is not
                     // reset each time the robot moves
       }

     /*
     * A method to reset recorded data
     */
    public void reset() {
         junctionCounter = 0;
         junctionRecorder.removeAll(junctionRecorder);
         explorerMode = 1;
       }
  }
